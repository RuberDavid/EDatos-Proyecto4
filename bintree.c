
#include <stdlib.h>
#include <string.h>

#include "bintree.h"

/*****************************************************************************
*                                                                            *
*  ------------------------------ bintree_init -----------------------------  *
*                                                                            *
*****************************************************************************/

void bintree_init(BinTree *tree, void (*destroy)(void *data) )
{

	/*****************************************************************************
	*                                                                            *
	*  Inicializa el arbol binario                                               *
	*                                                                            *
	*****************************************************************************/

	tree->size = 0;
	tree->destroy = destroy;
	tree->root = NULL;

	return;

}

/*****************************************************************************
*                                                                            *
*  --------------------------- bintree_rem_right ---------------------------  *
*                                                                            *
*****************************************************************************/

void bintree_rem_right(BinTree *tree, BinTreeNode *node)
{

	BinTreeNode         **position;

	/*****************************************************************************
	*                                                                            *
	*  No permitir eliminar nodos de un árbol vacío                                 *
	*                                                                            *
	*****************************************************************************/

	if (bintree_size(tree) == 0)
	  	 return;

	/*****************************************************************************
	*                                                                            *
	*  Determinar dónde remover los nodos                                         *
	*                                                                            *
	*****************************************************************************/

	if (node == NULL)
		   position = &tree->root;
	else
		   position = &node->right;

	/*****************************************************************************
	*                                                                            *
	*  Remover nodos                                                         *
	*                                                                            *
	*****************************************************************************/

	if (*position != NULL)
	{

		   bintree_rem_left(tree, *position);
		   bintree_rem_right(tree, *position);

		   if (tree->destroy != NULL)
		   {

			      /***********************************************************************
			      *                                                                      *
			      *  llamada a función definida por el usuario para liberar datos   *
			      *                                                                      *
			      ***********************************************************************/

			      tree->destroy((*position)->data);

		   }

		   free(*position);
		   *position = NULL;

		   /**************************************************************************
		   *                                                                         *
		   *  Ajustar el tamaño del árbol 
		   *                                                                         *
		   **************************************************************************/

		   tree->size--;

	}

	return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- bintree_rem_left ---------------------------  *
*                                                                            *
*****************************************************************************/

void bintree_rem_left(BinTree *tree, BinTreeNode *node)
{

	BinTreeNode         **position;

	/*****************************************************************************
	*                                                                            *
	*  No permitir eliminar nodos de un árbol vacío                                 *
	*                                                                            *
	*****************************************************************************/

	if (bintree_size(tree) == 0)
		   return;

	/*****************************************************************************
	*                                                                            *
	*  Determinar dónde remover los nodos                                         *
	*                                                                            *
	*****************************************************************************/

	if (node == NULL)
	 	  position = &tree->root;
	else
	  	 position = &node->left;

	/*****************************************************************************
	*                                                                            *
	*  Remover nodos                                                         *
	*                                                                            *
	*****************************************************************************/

	if (*position != NULL)
	{

		   bintree_rem_left(tree, *position);
		   bintree_rem_right(tree, *position);

		   if (tree->destroy != NULL)
		   {

			      /***********************************************************************
			      *                                                                      *
			      *  llamada a función definida por el usuario para liberar datos   *
			      *                                                                      *
			      ***********************************************************************/

			      tree->destroy((*position)->data);

		   }

		   free(*position);
		   *position = NULL;

		   /**************************************************************************
		   *                                                                         *
		   *  Ajustar el tamaño del árbol 
		   *                                                                         *
		   **************************************************************************/

		   tree->size--;

	}

	return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- bintree_destroy ----------------------------  *
*                                                                            *
*****************************************************************************/

void bintree_destroy(BinTree *tree)
{

	/*****************************************************************************
	*                                                                            *
	*  Remeve todos los nodos del árbol.                                         *
	*                                                                            *
	*****************************************************************************/

	bintree_rem_left(tree, NULL);

	/*****************************************************************************
	*                                                                            *
	*  Limpia la estructura como precacución.
	*                                                                            *
	*****************************************************************************/

	memset(tree, 0, sizeof(BinTree));

	return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- bintree_ins_left ---------------------------  *
*                                                                            *
*****************************************************************************/

int bintree_ins_left(BinTree *tree, BinTreeNode *node, const void *data)
{

	BinTreeNode         *new_node,
			   **position;

	/*****************************************************************************
	*                                                                            *
	*  Determinar dónde insertar el nodo	                                       *
	*                                                                            *
	*****************************************************************************/

	if (node == NULL)
	{

		   /**************************************************************************
		   *                                                                         *
		   *  Permitir inserción en la raiz solo si en árbol es vacio                *
		   *                                                                         *
		   **************************************************************************/

		   if (bintree_size(tree) > 0)
		   	   return -1;

		   position = &tree->root;

	 }
	else
	{

		   /**************************************************************************
		   *                                                                         *
		   *  Permitir inserción al final de una rama
		   *                                                                         *
		   **************************************************************************/

		   if (bintree_left(node) != NULL)
		       	return -1;

		   position = &node->left;

	}

	/*****************************************************************************
	*                                                                            *
	*  Alojar memoria para el nodo
	*                                                                            *
	*****************************************************************************/

	if ((new_node = (BinTreeNode *)malloc(sizeof(BinTreeNode))) == NULL)
	 	  return -1;

	/*****************************************************************************
	*                                                                            *
	*  Insertar el nodo en el árbol
	*                                                                            *
	*****************************************************************************/

	new_node->data = (void *)data;
	new_node->left = NULL;
	new_node->right = NULL;
	*position = new_node;

	/*****************************************************************************
	*                                                                            *
	*  Ajustar tamaño
	*                                                                            *
	*****************************************************************************/

	tree->size++;

	return 0;

}

/*****************************************************************************
*                                                                            *
*  --------------------------- bintree_ins_right ---------------------------  *
*                                                                            *
*****************************************************************************/

int bintree_ins_right(BinTree *tree, BinTreeNode *node, const void *data)
{

	BinTreeNode         *new_node,
			   **position;

	/*****************************************************************************
	*                                                                            *
	*  Determinar dónde insertar el nodo
	*                                                                            *
	*****************************************************************************/

	if (node == NULL)
	{

		   /**************************************************************************
		   *                                                                         *
		   *  Permitir inserción en la raiz solo si el árbol está vacío
		   *                                                                         *
		   **************************************************************************/

		   if (bintree_size(tree) > 0)
			    return -1;

		   position = &tree->root;

	 }

	else
	{

		   /**************************************************************************
		   *                                                                         *
		   *  Permitir inserción en el final de la rama
		   *                                                                         *
		   **************************************************************************/

		   if (bintree_right(node) != NULL)
		  	    return -1;

		   position = &node->right;

	}

	/*****************************************************************************
	*                                                                            *
	*  Alojar memoria para el nodo
	*                                                                            *
	*****************************************************************************/

	if ((new_node = (BinTreeNode *)malloc(sizeof(BinTreeNode))) == NULL)
		   return -1;

	/*****************************************************************************
	*                                                                            *
	*  Insertar nodo en el árbol
	*                                                                            *
	*****************************************************************************/

	new_node->data = (void *)data;
	new_node->left = NULL;
	new_node->right = NULL;
	*position = new_node;

	/*****************************************************************************
	*                                                                            *
	*  Ajustar el tamaño del árbol
	*                                                                            *
	*****************************************************************************/

	tree->size++;

	return 0;

}

